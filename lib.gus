(def t 't)
(def hd t)
(def tl ())
(def id (fn (x) x))
(def list (fn xs xs))
(def or (fn xs (any? id xs)))
(def and (fn xs (all? id xs)))
(def nil? (fn (x) (eq? x ())))
(def const (fn (x) (fn (_) x)))
(def pair (fn (a b) `(,a . ,b)))
(def > (fn (a b) (not (<= a b))))
(def >= (fn (a b) (not (< a b))))
(def zip (fn (a b) (map* pair a b)))
(def <= (fn (a b) (or (< a b) (= a b))))
(def not (fn (x) ((truth x) '(() . t))))
(def truth (fn (a) ((nil? a) '(() . t))))
(def juxt (fn (a b) (fn (x) (pair (a x) (b x)))))
(def flip (fn (f) (fn xs (apply f (reverse xs)))))
(def reverse (fn (l) (fold (fn (m l) (pair l m)) () l)))
(def part (fn (f . xs) (fn ys (apply f (append xs ys)))))
(def uncurry (fn (n f) (fn xs (fold (fn (a b) (a b)) f xs))))
(def comp (fn fs (fold (fn (c f) (fn (x) (c (f x)))) id fs)))
(def map (fn (f l) (if l (pair (f (hd l)) (map f (tl l))) ())))
(def if (rw (a b c) `(((truth ,a) (pair (fn () ,b) (fn () ,c))))))
(def fold (fn (f h l) (if (nil? l) h (fold f (f h (hd l)) (tl l)))))
(def any? (fn (pred l) (if (nil? l) l (if (pred (hd l)) t (any? pred (tl l))))))
(def let (rw (bs . xp) `((fn ,(map hd bs) @xp) @(map (fn (p) (hd (tl p))) bs))))
(def all? (fn (pred l) (if (nil? l) t (if (pred (hd l)) (all? pred (tl l)) ()))))
(def append (fn (a b) (if (nil? a) b (if (nil? b) a (pair (t a) (append (() a) b))))))
(def range (fn (n) (def inner (fn (x) (if (= x n) () (pair x (inner (+ x 1)))))) (inner 0)))
(def filter (fn (pred l) (if (nil? l) l (let ((fd (filter pred (tl l)))) (if (pred (hd l)) (pair (hd l) fd) fd)))))
(def curry (fn (n f) ((fold (fn (f$ _) (fn (xs) (fn (x) (f$ (pair x xs))))) (fn (xs) (apply (flip f) xs)) (range n)) ())))
(def map* (fn (f . ls) (if (any? nil? ls) () (let ((vs (map hd ls)) (rs (map tl ls))) (pair (apply f vs) (apply map* (pair f rs)))))))
