(def t 't)
(def hd 't)
(def tl ())
(def id (fn (x) x))
(def const (fn (x) (fn (_) x)))
(def list (fn xs xs))
(def pair (fn (a b) `(,a . ,b)))
(def nil? (fn (x) (eq? x ())))
(def truth (fn (a) ((nil? a) (pair () t))))
(def if (rw (a b c) `(((truth ,a) (pair (fn () ,b) (fn () ,c))))))
(def let (rw (bs . xp) `((fn ,(map hd bs) @xp) @(map (fn (p) (hd (tl p))) bs))))
(def and (fn xs (fold (fn (a b) ((truth a) (pair b a))) t xs)))
(def or (fn xs (fold (fn (a b) ((truth a) (pair a b))) () xs)))
(def not (fn (x) ((truth x) (pair () t))))
(def <= (fn (a b) (or (< a b) (= a b))))
(def > (fn (a b) (not (<= a b))))
(def >= (fn (a b) (not (< a b))))
(def map (fn (f l) (if l (pair (f (hd l)) (map f (tl l))) ())))
(def map* (fn (f . ls) (if (any? nil? ls) () (let ((vs (map hd ls)) (rs (map tl ls))) (pair (apply f vs) (apply map* (pair f rs)))))))
(def zip (fn (a b) (map* pair a b)))
(def juxt (fn (a b) (fn (x) (pair (a x) (b x)))))
(def any? (fn (pred l) (if (nil? l) l (if (pred (hd l)) t (any? pred (tl l))))))
(def all? (fn (pred l) (if (nil? l) t (if (pred (hd l)) (all? pred (tl l)) ()))))
(def filter (fn (pred l) (if (nil? l) l (let ((fd (filter pred (tl l)))) (if (pred (hd l)) (pair (hd l) fd) fd)))))
(def fold (fn (f h l) (if (nil? l) h (fold f (f h (hd l)) (tl l)))))
(def reverse (fn (l) (fold (fn (m l) (pair l m)) () l)))
(def comp (fn fs (fold (fn (c f) (fn (x) (c (f x)))) id fs)))
(def flip (fn (f) (fn xs (apply f (reverse xs)))))
(def range (fn (n) (def inner (fn (x) (if (= x n) () (pair x (inner (+ x 1)))))) (inner 0)))
(def curry (fn (n f) ((fold (fn (f$ _) (fn (xs) (fn (x) (f$ (pair x xs))))) (fn (xs) (apply (flip f) xs)) (range n)) ())))
(def uncurry (fn (n f) (fn xs (fold (fn (a b) (a b)) f xs))))
(def append (fn (a b) (if (nil? a) b (if (nil? b) a (pair (t a) (append (() a) b))))))
(def part (fn (f . xs) (fn ys (apply f (append xs ys)))))
